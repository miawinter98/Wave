@page "/Category/{CategoryName}"
@using Microsoft.EntityFrameworkCore
@using Wave.Data
@using System.Net
@using Microsoft.Extensions.Options

@inject IDbContextFactory<ApplicationDbContext> ContextFactory
@inject IOptions<Customization> Customizations
@inject IOptions<Features> Features
@inject IStringLocalizer<CategoryView> Localizer

<HeadContent>
	@if (Features.Value.Rss && Category is not null) { 
		<link rel="alternate" type="application/rss+xml" title="RSS Feed on @Customizations.Value.AppName | @Category.Name" href="/rss/rss.xml?category=@WebUtility.UrlEncode(Category.Name)">
		<link rel="alternate" type="application/atom+xml" title="Atom RSS Feed on @Customizations.Value.AppName | @Category.Name" href="/rss/atom.xml?category=@WebUtility.UrlEncode(Category.Name)">
	}
	@if (Category is null) {
		<meta name="robots" content="noindex">
	}
</HeadContent>

<PageTitle>@($"{Category?.Name ?? "Not Found"} {TitlePostfix}")</PageTitle>

@if (Category is null) {
	<h1 class="text-3xl lg:text-5xl font-light mb-6 text-primary">@Localizer["NotFound_Title"]</h1>
	<p class="my-3">@Localizer["NotFound_Description"]</p>
	<a class="btn btn-primary" href="/">@Localizer["NotFound_BackToHome_Label"]</a>
} else {
	<h1 class="text-3xl lg:text-5xl font-light mb-6 text-primary">@Localizer["Title"] - @Category.Name</h1>
	
	<ArticleCardList Articles="Category.Articles" />
}

@code {
	[CascadingParameter(Name = "TitlePostfix")]
	private string TitlePostfix { get; set; } = default!;

	[Parameter]
	public string CategoryName { get; set; } = string.Empty;
	private Category? Category { get; set; }

	protected override async Task OnInitializedAsync() {
		await using var context = await ContextFactory.CreateDbContextAsync();
		string category = WebUtility.UrlDecode(CategoryName);
		var now = DateTimeOffset.UtcNow;
		// First load Category with simple chain and manual filters, as to minimize 
		// filter redundancy and query complexity (category -> Articles -> Author is linear)
		Category = await context.Set<Category>()
			.IgnoreAutoIncludes().IgnoreQueryFilters()
			.Include(c => c.Articles.Where(a => !a.IsDeleted && a.PublishDate <= now))
			.ThenInclude(a => a.Author)
			.FirstOrDefaultAsync(c => c.Name == category);
		// Load all the other categories missing on the articles, by loading all relevant 
		// articles ID with their categories, so EF can map them to the already loaded entries 
		// (again manual filter to minimize redundancy)
		await context.Set<Article>()
			.IgnoreAutoIncludes().IgnoreQueryFilters()
			.Where(a => !a.IsDeleted && a.PublishDate <= now && a.Categories.Contains(Category!))
			.Select(a => new {
				a.Id, a.Categories
			}).LoadAsync();
	}
}
